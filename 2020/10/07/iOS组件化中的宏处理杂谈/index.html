<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS组件化中的宏处理杂谈 · nakahira's Blog</title><meta name="description" content="iOS组件化中的宏处理杂谈 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="nakahira's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS组件化中的宏处理杂谈</h1><div class="post-info">2020年10月7日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几乎所有C家族的语言都在长期使用预处理器带来的宏功能，比如:常量定义、条件编译、代码生成、神奇的“语法糖”等……</p>
<p>但是如此好用的功能，我们务必要防止滥用，由于其作用面之大，可能因使用不当而带来的问题也会奇奇怪怪，所以本文的内容将围绕宏在iOS组件化中时所要面对的种种问题来进行阐述，最后会对所有问题进行一个总结并给出一个比较通用的使用建议。</p>
<h2 id="二进制化之前的问题"><a href="#二进制化之前的问题" class="headerlink" title="二进制化之前的问题"></a>二进制化之前的问题</h2><h3 id="宏的隔离性"><a href="#宏的隔离性" class="headerlink" title="宏的隔离性"></a>宏的隔离性</h3><p>这里我们将公开给外部使用的宏称为导出宏，而在组件化中，由于组件数量难以估计，甚至在某些大的公司有很多不同部门不同组的同事分别开发维护多个组件，而跨组跨部门沟通经常需要更多的成本，所以应尽量保持少导出宏，通过其他方式比如const常量、函数/方法声明向外界导出接口或数据，避免造成宏和宏、宏和变量、函数等同名出现的冲突，这种冲突在没有对编译器做一些设置的情况下往往只会产生警告，而不会出现明显的报错，导致在运行时出现莫名其妙的BUG。</p>
<h3 id="Clang模块化对宏的影响"><a href="#Clang模块化对宏的影响" class="headerlink" title="Clang模块化对宏的影响"></a>Clang模块化对宏的影响</h3><p>当某组件内依赖其他组件(外部)的宏，这里的依赖方式，需要注意一个问题，那就是你是显式的依赖(已经显式导入依赖的头文件，这里并不会产生问题)，还是隐式的依赖，隐式的依赖可能不太好理解，这里我举个例子:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModuleA.h</span></span><br><span class="line"><span class="meta">#define ModuleA_Var 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ModuleB.h</span></span><br><span class="line"><span class="meta"># ifdef ModuleA_Var</span></span><br><span class="line">	<span class="meta">#define ModuleB_Var 1</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">	<span class="meta">#define ModuleB_Var 2</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Business.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;ModuleA/ModuleA.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;ModuleB/ModuleB.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,ModuleB_Var);</span><br></pre></td></tr></table></figure>
<p>可以看到，业务方同时导入了ModuleA和ModuleB，而ModuleB实际上是依赖ModuleA中的宏的，但是却没有显式的导入它，而是在业务方代码里同时被一起引用了，这里我将它称为隐式的依赖。那么这里业务方打印这个ModuleB_Var是1还是2呢？</p>
<p>这里就引出了一个相当需要注意的问题，我们知道预处理器对于宏定义只是简单的文本替换，在使用的组件没有开启Module化时，这里的导入关系其实是依赖你的#import指令的先后顺序的，上面的例子里，打印出的会是1，而如果你将导出顺序交换一下，就会导致打印的是2；而在组件都开启Module化，业务方也开启使用Module功能之后(目前Xcode默认都会开启这两个选项)，这时候就不再是简单的文本替换，#import指令会根据是否满足条件(符合Module标准)自动变成@import指令，也就是从简单的文本导入变成模块导入，clang将产生一个干净上下文的预处理器来编译这个模块的头文件，并以二进制的形式缓存结果，以便重复给其他导入该模块的编译单元使用。所以在其之前导入的头文件ModuleA内容，实际上ModuleB是感知不到的，也许有人会觉得自己不会写这种代码，但是如果把ModuleA中的宏这个条件改成是来自PCH文件中的宏呢？这时候就更难察觉了。</p>
<p>所以这里的问题，其实就引出一个结论，那就是组件内的头文件不要依赖任何自己没有显示导入，而在导入自己之前在其他文件(其他组件)定义的宏，因为我们的代码要具备一定的健壮性，不管模块化是否开启，都应拥有同样的执行效果。</p>
<h3 id="宏的可变性"><a href="#宏的可变性" class="headerlink" title="宏的可变性"></a>宏的可变性</h3><p>实际上如果将宏进行一个大方向的分类，可以分为可变的和不可变的，其中不可变的较为常用，也更为通用，带来的问题也更少；而可变的宏一般使用在环境的切换中，其中某些特殊的热门三方库由于其考虑兼容性而需要添加一些预编译宏，这些实际上从使用者角度来说，其应该算是一个不可变的宏，因为可变与不可变性是来自使用者，而不是来自提供者。</p>
<p>那可变的宏会带来哪些问题呢？因为本文是按照二进制化之前和二进制化之后来区分问题阐述的，所以这里只引出在二进制化之前的问题，可变的宏在这里会带来一些编译性能的问题，因为其可变性造成了部分缓存失效而触发重新编译，倒并没有带来结果性的影响。</p>
<h2 id="二进制化时面对的问题"><a href="#二进制化时面对的问题" class="headerlink" title="二进制化时面对的问题"></a>二进制化时面对的问题</h2><p>前面已经阐述的问题，并不意味着二进制化后就没有那些问题，其实这是累加的，二进制化是在其基础上对宏的使用带来更加苛刻的条件，我们继续说。</p>
<h3 id="宏的消失"><a href="#宏的消失" class="headerlink" title="宏的消失"></a>宏的消失</h3><p>从标题来看就很清楚，因为一旦二进制化，组件内的宏因为已经完成编译，所以其内的宏就已经被替换完成，这里所说的消失指的是其被编译的实现文件，而不是指头文件。接上面宏的可变性继续说，如果宏不可变，那么二进制化后宏的消失也并不会出现问题，问题在于可变宏，因为其已经被替换完成，所以它不会再响应可变宏未来的任何变化，只能重新编译。</p>
<p>对于这种问题，我们可以按两种情况进行处理：</p>
<ol>
<li><p>方法内部使用宏</p>
<p>对于这种情况，其二进制化后宏消失的问题，我们可以提供一个始终不会被二进制化的源码组件(宏组件)，将所需的条件判断宏向外(也就是向二进制化的组件方)提供方法或函数接口，而这个宏组件在函数或方法内部通过判断宏来返回数据，大概如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏失效情况</span></span><br><span class="line"><span class="comment">// ModuleA内部</span></span><br><span class="line">- (<span class="keyword">void</span>)xxxx &#123;</span><br><span class="line">	<span class="meta">#if DEBUG</span></span><br><span class="line">		<span class="comment">// code</span></span><br><span class="line">	<span class="meta">#else</span></span><br><span class="line">		<span class="comment">// code</span></span><br><span class="line">	<span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理之后</span></span><br><span class="line"><span class="comment">// ModuleMacro</span></span><br><span class="line"><span class="comment">// Macro.h</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isDebug;</span><br><span class="line"><span class="comment">// Macro.m</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isDebug &#123;</span><br><span class="line">	<span class="meta">#if DEBUG</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	<span class="meta">#else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">	<span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModuleA内部</span></span><br><span class="line">- (<span class="keyword">void</span>)xxxx &#123;</span><br><span class="line">	<span class="keyword">if</span> ([Macro isDebug])&#123;</span><br><span class="line">		<span class="comment">// code</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法外部使用宏</p>
<p>而在方法外部使用的宏，解决方案就是通过重构将其改为方法内部使用的宏，比如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏失效情况</span></span><br><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> BaseAPI = <span class="string">@"&lt;https://xxx&gt;"</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> BaseAPI = <span class="string">@"&lt;https://xxx&gt;"</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理之后</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)baseAPI &#123;</span><br><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">@"&lt;https://xxx&gt;"</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">@"&lt;https://xxx&gt;"</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="如何安全的使用宏"><a href="#如何安全的使用宏" class="headerlink" title="如何安全的使用宏"></a>如何安全的使用宏</h2><p>关于如何更安全的使用宏，这里我给出以下几点建议:</p>
<ol>
<li>应该尽量避免组件向外导出宏和导入外部组件的宏，可变宏就不用多说，肯定不要导入或导出，而不可变的宏，如果能保证其宏接口的稳定性，可以适当使用，比如处理闭包循环引用的宏等。</li>
<li>在满足第1条的情况下，不要隐式依赖外部组件的宏，而应该显式导入，否则会出现依赖导入顺序和模块化后宏消失问题。</li>
<li>在满足第2条情况，不要出现两个组件循环依赖(这一条其实是属于组件拆分的问题)。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由于本人水平有限，如有发现勘误之处希望能被指出，同时也希望这些内容能够为需要的同学带来用处。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/08/23/iOS学习笔记-hmap文件/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'true';
var disqus_identifier = '2020/10/07/iOS组件化中的宏处理杂谈/';
var disqus_title = 'iOS组件化中的宏处理杂谈';
var disqus_url = 'http://yoursite.com/2020/10/07/iOS组件化中的宏处理杂谈/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//true.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>