<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JungHsu&#39;s Blog</title>

  
  <meta name="author" content="John Doe">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="JungHsu&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="JungHsu&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">JungHsu&#39;s Blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/12/07/老生常谈category增加属性的几种操作/"><span>老生常谈category增加属性的几种操作</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/07/老生常谈category增加属性的几种操作/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-07T15:35:15.000Z">
          2017-12-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 日常开发中，为一个已有的类(比如说不想影响其文件结构)、第三方库提供的类增加几个property，已经是十分常见且需要的操作了，有人会单独起草一份category.m文件，也有人直接继承，像我一般会用category，一是能减少类文件的数量提高编译速度，二也是为了代码结构更加清晰。</p>
<p> 这篇文章是用来写Category的进行属性扩展的行为的，所以我还是言归正传，首先，我要阐述一下目前比较主流的几个属性扩展形式，再往下进行分析:</p>
<ol>
<li>利用 objc_setAssociatedObject函数进行对象的联合。</li>
<li>利用 class_addProperty 函数进行类属性的扩展</li>
<li><p>通过内部创建一个其他对象(比如字典),通过重写本对象set和get或者消息转发。</p>
<p>下面对这三种常用方法进行分析，其实常见的都是前面两种，第三种也是比较非主流。在分析这三种之前，我要谈一下为什么不能用 class_addIvar 函数。</p>
</li>
</ol>
<ul>
<li>class_addIvar 函数<blockquote>
<p>在苹果文档中，对 class_addIvar 函数有下面一段话:</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This function may only be called after objc_allocateClassPair(_:_:_:) and before objc_registerClassPair(_:). Adding an instance variable to an existing class is not supported.</span><br><span class="line">The class must not be a metaclass. Adding an instance variable to a metaclass is not supported.</span><br><span class="line"></span><br><span class="line">这个功能只能在 objc_allocateClassPair(_:_:_:) 之后和 objc_registerClassPair(_:) 之前调用。不支持将实例变量添加到现有的类。</span><br><span class="line">该类不能是元类。不支持将实例变量添加到元类。</span><br></pre></td></tr></table></figure>
<p> 文档是说不能将此函数用于已有的类，必须是动态创建的类，为了能够知道为何会这样，我们需要翻阅一下苹果开源的 runtime 源码。</p>
<ol>
<li><p>首先看一下关于 objc_allocateClassPair 函数的代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">去除干扰代码，我们寻找到下面的函数调用链条:</span><br><span class="line">objc_allocateClassPair -&gt; objc_initializeClassPair_internal</span><br><span class="line"></span><br><span class="line">// 下面的代码已经被我大部分剔除，只留下我们分析所需要用到的代码</span><br><span class="line">static void objc_initializeClassPair_internal(Class superclass, const char *name, Class cls, Class meta)</span><br><span class="line">&#123;</span><br><span class="line">    // Set basic info</span><br><span class="line"></span><br><span class="line">    cls-&gt;data()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    meta-&gt;data()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    cls-&gt;data()-&gt;version = 0;</span><br><span class="line">    meta-&gt;data()-&gt;version = 7;</span><br><span class="line">    </span><br><span class="line">    // RW_CONSTRUCTING 类已分配但还未注册</span><br><span class="line">    // RW_COPIED_RO class_rw_t-&gt;ro 来自 class_ro_t 结构的复制</span><br><span class="line">    // RW_REALIZED //  class_t-&gt;data 的结构为 class_rw_t</span><br><span class="line">    // RW_REALIZING // 类已开始分配，但并未完成</span><br><span class="line">    // 以上几个宏都是对新类的class_rw_t结构设置基本信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是class_addIvar的与我分析所需要的实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 无关代码已经剔除</span><br><span class="line">BOOL </span><br><span class="line">class_addIvar(Class cls, const char *name, size_t size, </span><br><span class="line">              uint8_t alignment, const char *type)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return NO;</span><br><span class="line"></span><br><span class="line">    if (!type) type = &quot;&quot;;</span><br><span class="line">    if (name  &amp;&amp;  0 == strcmp(name, &quot;&quot;)) name = nil;</span><br><span class="line"></span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    // No class variables</span><br><span class="line">    if (cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Can only add ivars to in-construction classes.</span><br><span class="line">    if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 重点在这最后一句，前面我们已经看到 objc_allocateClassPair 函数所分配的新类的flags位信息，在此处 &amp; RW_CONSTRUCTING，必定为真，取反后跳过大括号向下执行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>已经存在的类，经过测试，flag位为 RW_REALIZED|RW_REALIZING,设置函数如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line">    </span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls == remapClass(cls));</span><br><span class="line"></span><br><span class="line">    // fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line"></span><br><span class="line">    ro = (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        // This was a future class. rw data is already allocated.</span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Normal class. Allocate writeable class data.</span><br><span class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro = ro;</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">所以在经过条件 !((RW_REALIZED | RW_REALIZING) &amp; RW_CONSTRUCTING) 时返回NO。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="以上便是对已有类不能使用-class-addIvar-函数的分析"><a href="#以上便是对已有类不能使用-class-addIvar-函数的分析" class="headerlink" title="以上便是对已有类不能使用 class_addIvar 函数的分析"></a>以上便是对已有类不能使用 class_addIvar 函数的分析</h2><h4 id="好了，回到真正的话题，对上面三种操作的分析"><a href="#好了，回到真正的话题，对上面三种操作的分析" class="headerlink" title="好了，回到真正的话题，对上面三种操作的分析:"></a>好了，回到真正的话题，对上面三种操作的分析:</h4><ul>
<li>objc_setAssociatedObject <blockquote>
<p>我们都知道，在category中使用property，可以生成set和get的方法声明，原因在此不做分析，一般为了方便的调用，我们都会写上property，关键在于没有set和get的实现，于是就会有下面这样的代码:</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void *key = &quot;key&quot;;</span><br><span class="line">@implementation Person (Extra)</span><br><span class="line"></span><br><span class="line">// 此处不考虑读写锁的问题</span><br><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的 objc_setAssociatedObject 函数内部的调用链条如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject -&gt; objc_setAssociatedObject_non_gc -&gt; _object_set_associative_reference</span><br><span class="line"></span><br><span class="line">// 其中主要操作都在 _object_set_associative_reference 函数中，内部实现类似一般属性的set实现(保留新值，释放旧值)，在此我们不进行深究，具体可以参考业内大佬的博客文章。</span><br></pre></td></tr></table></figure>
<p> 这种操作很直观的表达了我们的需要，且API十分友好，仅仅是对于 weak 策略我们需要自己设计一个。</p>
<p>并且这种操作的好处是我们无需关系关联对象的声明周期，因为和普通的属性一样，会随着宿主对象的释放而释放,具体可以看以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dealloc -&gt; _objc_rootDealloc -&gt; rootDealloc -&gt; object_dispose -&gt; objc_destructInstance</span><br><span class="line">// 大部分释放操作在 objc_destructInstance 函数中完成</span><br><span class="line"></span><br><span class="line">// 下面是 objc_destructInstance 函数的实现代码</span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class="line">        bool dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        // 内部通过C++的析构函数进行对象属性的释放，具体可看sunny大神的博文</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        // 此处会移除所有的关联对象，也就是objc_setAssociatedObject 函数所设置上去的对象</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        // 清空引用计数与weak表</span><br><span class="line">        if (dealloc) obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当然也有不足之处，利用 objc_setAssociatedObject 生成的关联对象无法直接利用目前主流的Json转Model库(原因是无法在ivar及property中遍历出来)。</p>
<ul>
<li>利用 class_addProperty 函数进行类属性的扩展</li>
</ul>
<p>class_addProperty 函数可以为我们生成类的property，@property是编译器的标识符，在普通类中可生成property、ivar、setMethod与getMethod，在我看来property的真实作用类似于方法的声明，后面我会再谈为什么。</p>
<p>在分类中使用class_addProperty和普通类一样， 只能生成set和get方法的声明，无论有没有被实现，我们都可以用 class_copyMethodList 函数得到property的list，如果这时候你想存储属性值，你依然必须手动或动态实现那些set和get方法，并且真实数据的存储也必须由你自己提供实现，比如可以使用前面所说的objc_setAssociatedObject 函数。</p>
<p>现在说说为啥property只是一个类似声明的作用呢，我们可以从苹果开源的代码中找到蛛丝马迹:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Class 是一个指向结构体 objc_class 的指针，而此结构体的结构如下所示:</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;  // 指向父类</span><br><span class="line">    cache_t cache;             // 缓存指针与vtable(没学过C++,没了解过虚函数这些)，加速方法的调用</span><br><span class="line">    class_data_bits_t bits;   // 真正保存对象的ivar，property与method等信息的地方</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    在源码中大部分时候表现为将类的大部分信息保存在 class_rw_t *rw指针中，不过内部也是返回bits中处理后的信息</span><br><span class="line">    </span><br><span class="line">        class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    在class_rw_t的结构中，结构如下所示:</span><br><span class="line">    struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;   // 类的信息标记</span><br><span class="line">    uint32_t version; // 当前运行时版本</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在class_rw_t的结构中，包含了另一个十分相似的 const class_ro_t *ro 成员变量。</p>
<p>这个成员变量为一个不可修改内容的结构体指针，其中存储了类在编译时就已经确定好的ivar、 property、method、protocol等信息，在类的初始化时会通过 methodizeClass 函数将其大部分内容都拷贝到 class_rw_t *rw中，其中 ivar 不会被拷贝，这也是前面所说的不能在运行时给已有的类增加 ivar的原因。</p>
<p>像property、method、protocol都是可以在运行时动态添加的，且存储到 rw 的结构中去。</p>
<p>好像说的有点跑题了，咱们还是一起看看property到底存储了什么信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，propperty中并没有存储很多信息，只有name和配置的属性，也没有实现函数的地址，所以前面我说property的作用其实和方法的声明是差不多的。</p>
<p>关于property的好处，也就是在使用网上json转model库时可以被遍历到了，但是如果你没有实现set和get，那依然会导致KVC的crash。</p>
<ul>
<li>通过内部创建一个其他对象(比如字典),通过重写本对象set和get或者消息转发。</li>
</ul>
<p>最后一种方法，也是比较少用的方式，说起来也比较简单，比如定义一个静态的字典变量，然后通过实现interface中声明的set和get的实现对这个字典变量做存取操作，或者通过消息转发中的 (id)forwardingTargetForSelector:(SEL)aSelector 方法返回这个字典变量，但是要注意本类中没有对转发做过什么事，不然这种方法也是不适用的。</p>
<h4 id="对上文的总结"><a href="#对上文的总结" class="headerlink" title="对上文的总结"></a>对上文的总结</h4><p>其实刚刚所描述的三种分类策略并不是很严谨，因为其中几种总是会搭配着使用，所以在此也要选择一个比较均衡的策略来实现Category属性的绑定。</p>
<blockquote>
<p>建议的策略:</p>
<ol>
<li>由于我们肯定会在interface 中提供生的property（由于没有合成实现与ivar，在此称为生的），所以这样对于在外部访问时和普通property相同。</li>
<li>由于缺乏的是实现以及可以存取的数据量，这里我们可以直接实现这些set与get。</li>
<li>set与get的实现可以通过 associatedObject 进行对对象的存取操作。</li>
</ol>
<p>好处： 这种操作由于提供了生的property，所以在第三方的json转model库遍历property时可以直接遍历到，由于你手动实现了set与get，所以在遍历后的KVC赋值时也能起到作用，保证了和普通成员变量的操作一致性。</p>
</blockquote>
<p>估计会有人看完结论后觉得:“ 我本来就是这么写的啊，你写这么多字到头来得出的结论和我平时写的也一样。”是的，我只能略表抱歉啦😏！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/12/07/老生常谈category增加属性的几种操作/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>


  <article>

  
    
    <h3 class="article-title"><a href="/2017/12/05/关于线上检测主线程卡顿的问题/"><span>关于线上检测主线程卡顿的问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/05/关于线上检测主线程卡顿的问题/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-05T09:53:40.000Z">
          2017-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>大家好，一年多没有更新文章了，最大的原因我想是不知道该分享些什么，这次是在一个巧合下发现网上经常被人讨论的APP在线上状态如何检测到主线程的卡顿情况，我也稍微了解了一下，前段时间就在一个博主的文章里看到一篇有部分讲解这个问题的，据说美团用的也是这种方案，具体不得而知，然后我发现网上关于这种问题的实现方案都十分类似，如果屏幕前的你还没有意识过这个问题，那就请听我往下分析这个网上常用的检测方案:</p>
<blockquote>
<p>利用runloop的检测方案</p>
</blockquote>
<p>关于runloop是什么我就不多说了，因为网上有很多关于这个的文章，最推荐的还是YYKit的作者博客上那篇。<br>我要拿出来注意的是 runloop 的状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>网上热议的是利用 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 这两个状态之间的耗时进行判断是否有太多事件处理导致出现了卡顿，下面直接上代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</span><br><span class="line">&#123;</span><br><span class="line">    PingConfig *object = (__bridge PingConfig*)info;</span><br><span class="line">    </span><br><span class="line">    // 记录状态值</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line"></span><br><span class="line">    // 发送信号</span><br><span class="line">    dispatch_semaphore_t semaphore = object-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这些是监听runloop的状态而写的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">    PingConfig *config = [PingConfig new];</span><br><span class="line">    // 创建信号</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    config-&gt;semaphore = semaphore;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)config,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    __block uint8_t timeoutCount = 0;</span><br><span class="line"></span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        while (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line"></span><br><span class="line">            if (st != 0)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">//                NSLog(@&quot;循环中--%ld&quot;,config-&gt;activity);</span><br><span class="line">                if (config-&gt;activity==kCFRunLoopBeforeSources || config-&gt;activity==kCFRunLoopAfterWaiting)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (++timeoutCount &lt; 5)&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        NSLog(@&quot;卡顿了&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我解读一下这段代码:</p>
<ol>
<li>PingConfig 只是我随便写的一个用来存储runloop的状态和信号量的自定义类，其中的结构如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface PingConfig : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    CFRunLoopActivity activity;</span><br><span class="line">    dispatch_semaphore_t semaphore;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>恩，只有这么多足矣。</p>
<ol>
<li>APP启动时我可以进入 registerObserver 方法，其中首先我创建一个记录信息的类PingConfig实例，然后创建一个信号，并且保存在这个PingConfig实例中(其实只是为了方便拿到)。</li>
<li>接下来我创建了一个观察者监测主线程的 runloop,它会在主线程runloop状态切换时进行回调。</li>
<li>开启一个子线程，并且在里面进行一个 while 循环，在 循环的开始处 wait 一个信号量，并且设置超时为 50毫秒，失败后会返回一个非0数，成功将会返回0，这时候线程会阻塞住等待一个信号的发出。</li>
<li>如果runloop状态正常切换，那么就会进入回调函数，在回调函数中我们发出一个信号，并且记录当前状态到PingConfig实例中，下面的判断语句中发现为0，timeoutCount自动置为0，一切正常。</li>
<li>当主线程出现卡顿，while循环中的信号量再次等待，但是回调函数没有触发，从而导致等待超时，返回一个非0数，进入判断句后，我们再次判断状态是否处于 kCFRunLoopBeforeSources 或 kCFRunLoopAfterWaiting，如果成立，timeoutCount+1。</li>
<li>持续五次runloop不切换状态，说明runloop正在处理某个棘手的事件无法休息且不更新状态，这样while循环中的信号量超时会一直发生，超过五次后我们将断定主线程的卡顿并上传堆栈信息。</li>
</ol>
<p>经过测试，的确可以检测到主线程的卡顿现象，不得不佩服大佬们的方案。<br>但是在一次测试中，发现当主线程卡在界面尚未完全显示前，这个方案就检测不出来卡顿了，比如我将下面的代码放在B控制器中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t t = dispatch_semaphore_create(0);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;----&quot;);</span><br><span class="line">    dispatch_semaphore_signal(t);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_semaphore_wait(t, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure></p>
<p>上面是一段有问题的代码，将导致主线程的持续堵塞，如果我们在这段代码放在B控制器的ViewDidLoad方法中(ViewWillAppear同样)，这样运行后，当你希望push到B控制器时，项目将在上一个界面完全卡住，并且无法用上面的方案检测到，而且CPU及内存都显示正常:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1336067-12058a76334f6d36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170930-153549@2x.png"></p>
<p>具体原因我想了一下，由于runloop在处理完source0或者source1后，比如界面的跳转也是执行了方法，具体有没有用到source0这不重要，但是后面会紧接着进入准备睡眠(kCFRunLoopBeforeWaiting)的状态，然而此时线程的阻塞导致runloop的状态也被卡住无法切换，这样也就导致在那段检测代码中无法进入条件，从而检测不出来。<br>但是话说回来，APP在静止状态(保持休眠)和刚刚那种卡死状态都会使runloop维持在 kCFRunLoopBeforeWaiting状态，这样我们就无法在那段代码中增加判断来修复，因为无法知道到底是真的静止没有操作还是被阻塞住，我也没找到线程的阻塞状态属性，如果你发现这个属性，那么就可以使用那个属性来判断。但是我也得说下在没找到那个属性时我的检测方案：</p>
<blockquote>
<p>我的检测方案</p>
</blockquote>
<p>先上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, serialQueue);</span><br><span class="line">dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 0.25 * NSEC_PER_SEC, 0);</span><br><span class="line"></span><br><span class="line">__block int8_t chokeCount = 0;</span><br><span class="line">dispatch_semaphore_t t2 = dispatch_semaphore_create(0);</span><br><span class="line">dispatch_source_set_event_handler(self.timer, ^&#123;</span><br><span class="line">    if (config-&gt;activity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">        static BOOL ex = YES;</span><br><span class="line">        if (ex == NO) &#123;</span><br><span class="line">            chokeCount ++;</span><br><span class="line">            if (chokeCount &gt; 40) &#123;</span><br><span class="line">                NSLog(@&quot;差不多卡死了&quot;);</span><br><span class="line">                dispatch_suspend(self.timer);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;卡顿了&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            ex = YES;</span><br><span class="line">            dispatch_semaphore_signal(t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        BOOL su = dispatch_semaphore_wait(t2, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">        if (su != 0) &#123;</span><br><span class="line">            ex = NO;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(self.timer);</span><br></pre></td></tr></table></figure></p>
<p>解释一下我的方案:</p>
<ol>
<li>开启一个异步队列，并且创建一个定时器，时间我设置的是0.25秒，具体时间随你自己，这个时间是用来检测卡死的持续时间。</li>
<li>在定时器外面我也同样创建了一个用来同步的信号量，这个不解释了，不会的就去看一下信号量的使用方式。进入定时器的回调后，我设置了一个静态变量来记录主队列是否执行完成。</li>
<li>我们判断当前runloop的状态是否为kCFRunLoopBeforeWaiting，所以这个方案是用来弥补前面那个方案，如果主线程此时没有阻塞住，我们在这里向main Queue抛一个block，看它是否能够成功执行，如果成功执行，说明主线程没有阻塞住，如果已经被阻塞住，那我抛过去的block是肯定不会被执行的。</li>
<li>下面的代码就是一些辅助操作，当信号量超过50毫秒，抛给主线程的block没有执行，那么说明此时就有一些阻塞了，返回一个非0数，并设置 ex为NO，从而在下一次定时器回调到来时进行上报。</li>
</ol>
<p>我写的这段解决方案中的示例代码只是用来演示，具体是原理可以大家尽情在此基础上优化，目前在我的项目中可以正常检测到之前那种阻塞造成的APP卡死现象，如果你发现有更好的检测方案，希望能告诉我，谢谢！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/12/05/关于线上检测主线程卡顿的问题/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 John Doe
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>